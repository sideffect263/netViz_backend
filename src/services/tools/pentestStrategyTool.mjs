const { Tool } = require("langchain/tools");
const { Client } = require("@modelcontextprotocol/sdk/client/index.js");
const { StreamableHTTPClientTransport } = require("@modelcontextprotocol/sdk/client/streamableHttp.js");
const { createSmitheryUrl } = require("@smithery/sdk/shared/config.js");

// It's crucial to manage API keys securely, e.g., via environment variables.
// Ensure SMITHERY_NMAP_API_KEY is set in your .env file or environment.
const SMITHERY_NMAP_API_KEY = process.env.SMITHERY_NMAP_API_KEY || "your-smithery-api-key-placeholder"; 
const PENTEST_THINKING_MCP_SERVER_URL = process.env.PENTEST_THINKING_MCP_SERVER_URL || "https://server.smithery.ai/@ibrahimsaleem/pentestthinkingmcp";

class PentestStrategyTool extends Tool {
    name = "pentest_strategy_advisor";
    description = `Provides expert penetration testing strategy, suggests the next logical attack step, and recommends appropriate tools based on the current state of a penetration test or CTF. 
    Input should be a clear description of the current situation, including:
    1. The target (IP address or hostname).
    2. A summary of known information, such as open ports, services identified, vulnerabilities discovered, or user access obtained.
    3. The current objective (e.g., "gain initial access", "enumerate services on port 80", "escalate privileges from user to root").
    Example input: "Target: 10.10.10.10. Findings: Nmap scan shows port 80 (HTTP) and port 22 (SSH) are open. Apache 2.4.49 is running on port 80. Objective: Enumerate web server further."`;
    
    mcpClient;
    isInitialized = false;

    constructor() {
        super();
        this.initializeClient().catch(error => {
            console.error("Failed to initialize PentestStrategyTool MCP client:", error);
            // Potentially set a flag or state indicating the tool is not operational
        });
    }

    async initializeClient() {
        if (SMITHERY_NMAP_API_KEY === "your-smithery-api-key-placeholder") {
            console.warn("PentestStrategyTool: SMITHERY_NMAP_API_KEY is not set. The tool may not function correctly.");
        }

        const config = {}; // Add any specific Smithery config if needed
        const serverUrl = createSmitheryUrl(PENTEST_THINKING_MCP_SERVER_URL, { 
            config, 
            apiKey: SMITHERY_NMAP_API_KEY 
        });

        const transport = new StreamableHTTPClientTransport(serverUrl);
        this.mcpClient = new Client({
            name: "NetVizAIAgent-PentestClient",
            version: "1.0.0"
        });

        try {
            await this.mcpClient.connect(transport);
            const serverTools = await this.mcpClient.listTools();
            console.log(`PentestStrategyTool: Connected to PentestThinkingMCP. Available server tools: ${serverTools.map(t => t.name).join(", ")}`);
            // We need to know the exact name of the tool on the MCP server to call.
            // Let's assume it's 'planAttackStep' or similar based on its functionality.
            // This might require inspection of the PentestThinkingMCP server's exposed tools.
            this.isInitialized = true;
        } catch (error) {
            console.error("PentestStrategyTool: Error connecting to PentestThinkingMCP server:", error);
            this.isInitialized = false;
            throw new Error("PentestStrategyTool failed to connect to its expertise server.");
        }
    }

    async _call(input) {
        if (!this.isInitialized || !this.mcpClient) {
            // Attempt re-initialization if not done or failed previously
            if (!this.isInitialized) {
                try {
                    console.log("PentestStrategyTool: Attempting to re-initialize client before call.");
                    await this.initializeClient();
                } catch (initError) {
                     return "Error: Pentest Strategy Advisor tool is not initialized or failed to connect to its server. Please check server logs.";
                }
            }
            if (!this.isInitialized) { // Check again after attempt
                 return "Error: Pentest Strategy Advisor tool could not be initialized. Cannot process request.";
            }
        }

        // The PentestThinkingMCP server's documentation implies it takes an "attackStep" as input.
        // The 'input' to this _call method *is* that attackStep, formulated by the LLM based on this tool's description.
        const attackStep = input; 

        try {
            // IMPORTANT: We need to know the exact name of the tool exposed by PentestThinkingMCP
            // and its expected input schema. Assuming a tool named 'planNextStep' or 'getAttackStrategy'
            // that accepts an object like { attackStep: "..." } or just the string.
            // For this example, let's assume it has a tool named "executeStep" or "planPentestStep"
            // If the MCP server just takes a direct message or a default tool handles it,
            // the interaction might be different (e.g., client.sendRequest directly).

            // Let's try to find a suitable tool. Common names might be:
            // "get_next_attack_step", "planAttackStep", "pentestReasoning", "nextStep"
            // This is a placeholder, replace "determineNextPentestStep" with the actual tool name
            // exposed by the PentestThinkingMCP server.
            const mcpToolName = "determineNextPentestStep"; // <<<< MUST BE VERIFIED

            // Check if the tool exists
            const availableTools = await this.mcpClient.listTools();
            const targetTool = availableTools.find(t => t.name === mcpToolName);

            if (!targetTool) {
                console.error(`PentestStrategyTool: The MCP server does not have a tool named '${mcpToolName}'. Available tools: ${availableTools.map(t => t.name).join(', ')}`);
                return `Error: Pentest Strategy Advisor could not find the required capability ('${mcpToolName}') on the expertise server.`;
            }
            
            console.log(`PentestStrategyTool: Calling MCP tool '${mcpToolName}' with input: ${attackStep}`);

            // The input structure for the MCP tool call depends on how PentestThinkingMCP's tool is defined.
            // Assuming it takes an object with a property matching one of its input schema fields.
            // Let's assume it takes a simple object like { "current_state": attackStep } or just the string.
            // If the tool schema has an input field, say, "inputQuery" or "currentStateDescription"
            // const mcpToolInput = { "currentStateDescription": attackStep };
            // For now, let's assume the tool directly takes the attackStep string as the primary input,
            // and the MCP SDK handles wrapping it correctly or the tool on the server is designed for it.
            // This might need to be: client.invokeTool(mcpToolName, { attackStepProperty: attackStep })
            
            // The invokeTool method typically takes the tool name and a JSON object for arguments.
            // Based on "Input: attackStep: 'Start with initial recon on 10.10.10.10'", let's assume
            // the tool on the MCP server expects an object like: { "attackStep": "your step here" }
            const response = await this.mcpClient.invokeTool(mcpToolName, { "attackStep": attackStep });

            console.log("PentestStrategyTool: Received response from MCP server:", response);

            // Process the response. The structure of 'response' depends on PentestThinkingMCP.
            // It might be JSON, or a string. Let's assume it's an object with fields like
            // 'nextStep', 'recommendedTool', 'rationale', 'attackChain'.
            if (response && typeof response === 'object') {
                // Example: Convert to a readable string for the LLM
                let resultString = "Expert Pentest Strategy:\n";
                if (response.nextStep) resultString += `Next Recommended Step: ${response.nextStep}\n`;
                if (response.recommendedTool) resultString += `Recommended Tool: ${response.recommendedTool}\n`;
                if (response.rationale) resultString += `Rationale: ${response.rationale}\n`;
                if (response.criticalPath) resultString += `Critical Path Insight: ${response.criticalPath}\n`;
                if (response.attackChain && Array.isArray(response.attackChain)) {
                    resultString += "Full Attack Chain Suggestion:\n" + response.attackChain.map((step, i) => `  ${i+1}. ${step}`).join("\n");
                }
                return resultString;
            } else if (typeof response === 'string') {
                return `Expert Pentest Strategy: ${response}`;
            } else {
                return "Pentest Strategy Advisor received an unexpected response format from the expertise server.";
            }

        } catch (error) {
            console.error("PentestStrategyTool: Error calling PentestThinkingMCP server:", error);
            return `Error: Pentest Strategy Advisor encountered an issue: ${error.message}`;
        }
    }
}

// Singleton instance for the tool
const pentestStrategyTool = new PentestStrategyTool();

module.exports = {
    PentestStrategyTool,
    pentestStrategyTool // Export instance
}; 